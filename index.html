<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Snake Game ‚Äî Clean Graphical (Sound)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --bg-1: #061024;
      --bg-2: #081426;
      --muted: #9fb0c8;
      --accent-2: #7c5cff;
      --accent-3: #00d4ff;
      --cell-size: 26px;
      --gap: 4px;
      --rounded: 12px;
      --shadow-lg: 0 14px 40px rgba(1,6,20,0.7);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:
      radial-gradient(800px 400px at 10% 10%, rgba(124,92,255,0.06), transparent 8%),
      radial-gradient(600px 300px at 90% 90%, rgba(0,212,255,0.04), transparent 8%),
      linear-gradient(180deg,var(--bg-1),var(--bg-2));color:#e8f3ff;-webkit-font-smoothing:antialiased;
      overflow:hidden; /* remove page scrollbar */
    }
    .container{height:100vh;display:flex;align-items:center;justify-content:center;padding:18px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.03);box-shadow:var(--shadow-lg);backdrop-filter:blur(6px)}
    .header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent-2),var(--accent-3));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;font-size:18px}
    h1{margin:0;font-size:20px}
    .subtitle{color:var(--muted);font-size:13px;margin-top:6px}

    .layout{display:flex;gap:22px;align-items:flex-start;justify-content:center;width:100%;max-width:1220px}
    .leftPanel{width:360px;flex:0 0 360px;max-height:calc(100vh - 80px);overflow:auto;padding-right:6px}
    .centerPanel{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center}

    .infoCard{display:flex;flex-direction:column;gap:10px}
    .infoRow{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px}

    /* board */
    .boardCard{position:relative;border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,0.03);box-shadow:var(--shadow-lg);background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);display:flex;flex-direction:column;align-items:center}
    #game-board{
      --cell: var(--cell-size);
      width: calc(15 * var(--cell) + 14 * var(--gap));
      height: calc(15 * var(--cell) + 14 * var(--gap));
      display:grid;
      grid-template-columns: repeat(15, var(--cell));
      grid-template-rows: repeat(15, var(--cell));
      gap: var(--gap);
      margin:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.012), transparent);
      padding: var(--gap);
      border-radius: 10px;
      touch-action: none;
    }
    .cell{width:var(--cell);height:var(--cell);border-radius:8px;background:linear-gradient(180deg,#0e1520,#0a1118);transition:transform .12s, background .12s, box-shadow .12s;position:relative;overflow:hidden}
    .cell.snake{background:linear-gradient(180deg,#7fc4ff,#2b8aef);box-shadow:0 8px 22px rgba(43,138,239,0.2);transform:scale(1.03)}
    .cell.snake.head::after{content:'';position:absolute;inset:0;border-radius:inherit;box-shadow:0 8px 30px rgba(43,138,239,0.28), 0 0 18px rgba(124,92,255,0.06);mix-blend-mode:screen}
    .cell.food{background:linear-gradient(180deg,#ffd27a,#ff9a5a);box-shadow:0 10px 26px rgba(255,139,79,0.18);transform:scale(1.05);animation:foodPulse 1100ms infinite}
    @keyframes foodPulse{0%{transform:scale(0.98)}50%{transform:scale(1.08)}100%{transform:scale(0.98)}}
    .cell.block{background:linear-gradient(180deg,#2b2f36,#4a4f58);box-shadow:inset 0 -6px 12px rgba(0,0,0,0.4)}
    .controls{display:flex;gap:8px;justify-content:center;margin-top:12px}
    .btn{padding:10px 14px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent-2),var(--accent-3));color:white;font-weight:700;cursor:pointer;box-shadow:0 8px 26px rgba(124,92,255,0.14);transition:transform .12s}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:none}
    .btn:active{transform:translateY(1px)}
    .controls .btn{min-width:56px;border-radius:10px;padding:8px 12px}
    #overlay{display:none;position:fixed;inset:0;z-index:1000;background:rgba(1,6,20,0.7);backdrop-filter:blur(6px);align-items:center;justify-content:center}
    .overlay-inner{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center;min-width:320px;max-width:92%}
    .count{font-size:3rem;font-weight:800;margin:10px 0}
    footer{color:var(--muted);text-align:center;margin-top:12px;font-size:13px;position:fixed;left:0;right:0;bottom:12px;pointer-events:none}
    /* audio controls */
    .audioControls{display:flex;align-items:center;gap:10px;margin-top:12px}
    .toggleSound{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);cursor:pointer}
    .volumeRange{width:120px}

    @media (max-width:920px){
      .container{padding:12px}
      .layout{flex-direction:column;align-items:center}
      .leftPanel{width:100%}
      #game-board{transform:scale(.92);transform-origin:center;margin:auto}
    }
  </style>
</head>
<body>
  <audio id="bgm" src="Montagem Bandido - YouTube.mp3" loop></audio>
  <button id="toggleMusic" style="position:absolute; top:10px; right:10px;">üîä B·∫≠t/T·∫Øt nh·∫°c</button>
  <div class="container">
    <div class="layout">
      <div class="leftPanel">
        <div class="card">
          <div class="header">
            <div class="logo">S</div>
            <div>
              <h1>Snake ‚Äî Clean</h1>
              <div class="subtitle">B·∫£n c√≥ √¢m thanh ‚Äî full room</div>
            </div>
          </div>

          <div class="infoCard" style="margin-top:12px">
            <div class="infoRow"><div>Score</div><div id="scoreDisplay">0</div></div>
            <div class="infoRow"><div>Level</div><div id="levelDisplay">1</div></div>
            <div class="infoRow"><div>Status</div><div id="statusText">ƒêang ·ªü Lobby</div></div>

            <div style="margin-top:12px;color:var(--muted);font-size:13px">H∆∞·ªõng d·∫´n: m≈©i t√™n / WASD ‚Ä¢ H·ªó tr·ª£ ch·∫°m tr√™n mobile</div>

            <div class="audioControls" title="√Çm nh·∫°c & hi·ªáu ·ª©ng">
              <button id="toggleSoundBtn" class="toggleSound">üîä B·∫≠t</button>
              <input id="volRange" class="volumeRange" type="range" min="0" max="100" value="70" />
              <div style="color:var(--muted);font-size:13px">Volume</div>
            </div>

            <div style="display:flex;gap:8px;margin-top:12px">
              <button id="resetBtn" class="btn ghost">Reset</button>
              <button id="leaveBtn" class="btn ghost">Tho√°t</button>
            </div>
          </div>
        </div>
      </div>

      <div class="centerPanel">
        <div class="boardCard card">
          <div id="game-board" aria-label="game board"></div>
          <canvas id="particles" style="position:absolute;left:0;top:0;pointer-events:none;"></canvas>

          <div class="controls" style="margin-top:18px">
            <button id="up" class="btn ghost">‚ñ≤</button>
            <button id="left" class="btn ghost">‚óÄ</button>
            <button id="down" class="btn ghost">‚ñº</button>
            <button id="right" class="btn ghost">‚ñ∂</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay" role="dialog" aria-hidden="true">
    <div class="overlay-inner">
      <div id="overlayMsg" style="font-weight:700;"></div>
      <div id="countdown" class="count"></div>
      <div style="margin-top:12px"><button id="overlayBtn" class="btn" style="display:none">OK</button></div>
    </div>
  </div>

  <footer>&copy; <span id="year"></span> Snake Game ‚Äî Clean Edition</footer>

  <script>
    // Auto year
    document.getElementById('year').textContent = new Date().getFullYear();

    // Game constants & elements
    const boardSize = 15;
    const board = document.getElementById('game-board');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const statusText = document.getElementById('statusText');
    const overlay = document.getElementById('overlay');
    const overlayMsg = document.getElementById('overlayMsg');
    const overlayBtn = document.getElementById('overlayBtn');
    const countdownEl = document.getElementById('countdown');
    const particlesCanvas = document.getElementById('particles');
    const pctx = particlesCanvas.getContext ? particlesCanvas.getContext('2d') : null;

    // Audio variables
    let audioCtx = null;
    let masterGain = null;
    let musicInterval = null;
    let currentMusicOsc = [];
    let audioEnabled = localStorage.getItem('snake_audio_enabled') !== 'false';
    let audioVolume = parseFloat(localStorage.getItem('snake_audio_volume') || '0.7');

    // Reflect initial UI
    const toggleBtn = document.getElementById('toggleSoundBtn');
    const volRange = document.getElementById('volRange');
    volRange.value = Math.round(audioVolume * 100);
    toggleBtn.textContent = audioEnabled ? 'üîä B·∫≠t' : 'üîà T·∫Øt';

    function initAudioIfNeeded() {
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = audioVolume;
        masterGain.connect(audioCtx.destination);
      } catch (e) {
        console.warn('AudioContext kh√¥ng h·ªó tr·ª£:', e);
        audioCtx = null;
      }
    }

    function resumeAudioContext() {
      if (!audioCtx) initAudioIfNeeded();
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    // Simple note player (sine with envelope)
    function playTone(freq, duration = 200, type = 'sine', when = 0, gain = 0.12) {
      if (!audioCtx) return null;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime + when/1000);
      g.gain.setValueAtTime(0, audioCtx.currentTime + when/1000);
      g.gain.linearRampToValueAtTime(gain, audioCtx.currentTime + when/1000 + 0.01);
      g.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + when/1000 + duration/1000);
      osc.connect(g);
      g.connect(masterGain);
      osc.start(audioCtx.currentTime + when/1000);
      osc.stop(audioCtx.currentTime + when/1000 + duration/1000 + 0.05);
      return osc;
    }

    // Effects
    function playEatSound() {
      resumeAudioContext();
      if (!audioEnabled) return;
      playTone(880, 90, 'sine', 0, 0.12);
      playTone(1320, 120, 'sine', 90, 0.08);
    }
    function playLevelUpSound() {
      resumeAudioContext();
      if (!audioEnabled) return;
      playTone(880, 140, 'triangle', 0, 0.14);
      playTone(1320, 220, 'triangle', 120, 0.12);
    }
    function playGameOverSound() {
      resumeAudioContext();
      if (!audioEnabled) return;
      playTone(600, 120, 'sawtooth', 0, 0.14);
      playTone(480, 260, 'sawtooth', 120, 0.12);
      playTone(360, 380, 'sawtooth', 300, 0.1);
    }

    // Background music loop (simple arpeggio)
    function startBackgroundMusic() {
      if (!audioCtx || !audioEnabled) return;
      stopBackgroundMusic();
      // pattern using scheduled short notes
      const pattern = [440, 660, 880, 660]; // a simple pattern
      const intervalMs = 350;
      musicInterval = setInterval(() => {
        pattern.forEach((f, i) => playTone(f, 250, 'sine', i * 90, 0.035));
      }, intervalMs);
    }
    function stopBackgroundMusic() {
      if (musicInterval) {
        clearInterval(musicInterval);
        musicInterval = null;
      }
    }

    function setAudioEnabled(enabled) {
      audioEnabled = enabled;
      localStorage.setItem('snake_audio_enabled', enabled ? 'true' : 'false');
      toggleBtn.textContent = enabled ? 'üîä B·∫≠t' : 'üîà T·∫Øt';
      if (enabled) {
        resumeAudioContext();
        startBackgroundMusic();
      } else {
        stopBackgroundMusic();
      }
    }
    function setAudioVolume(v) {
      audioVolume = v;
      localStorage.setItem('snake_audio_volume', String(v));
      if (masterGain) masterGain.gain.value = v;
    }

    toggleBtn.addEventListener('click', () => {
      // first user gesture will initialize audio
      initAudioIfNeeded();
      resumeAudioContext();
      setAudioEnabled(!audioEnabled);
    });
    volRange.addEventListener('input', (e) => {
      const v = Number(e.target.value)/100;
      setAudioVolume(v);
    });

    // Reflect stored state: initialize audio context lazily on first user action
    if (audioEnabled) {
      // don't auto-start audio until user gesture; but prepare context if already allowed later
      // We'll start music when user performs any act (reset or keydown)
    }

    // Game variables
    let snake, direction, food, score, gameInterval, foodEaten;
    let level;
    let nextDirection = null;
    let isCounting = false;
    const cells = [];

    // levels
    const levels = [
      Array(boardSize).fill(0).map(() => Array(boardSize).fill(0)),
      Array(boardSize).fill(0).map((_, y) => Array(boardSize).fill(0).map((_, x) => (x === 0 || x === boardSize-1 || y === 0 || y === boardSize-1) ? 1 : 0)),
      Array(boardSize).fill(0).map((_, y) => Array(boardSize).fill(0).map((_, x) => (x === Math.floor(boardSize/2) || y === Math.floor(boardSize/2)) ? 1 : 0)),
    ];

    // Build board
    function buildBoard(){
      board.innerHTML = '';
      cells.length = 0;
      for (let y=0; y<boardSize; y++){
        for (let x=0; x<boardSize; x++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.x = x; cell.dataset.y = y;
          board.appendChild(cell);
          cells.push(cell);
        }
      }
      resizeParticles();
      drawLobbyHint();
    }
    buildBoard();

    function getIndex(x,y){ return y * boardSize + x; }

    function draw(){
      cells.forEach(c => c.className = 'cell');
      for (let y=0;y<boardSize;y++){
        for (let x=0;x<boardSize;x++){
          if (levels[level][y][x] === 1) cells[getIndex(x,y)].classList.add('block');
        }
      }
      snake.forEach((part, idx) => {
        const c = cells[getIndex(part.x, part.y)];
        c.classList.add('snake');
        if (idx === 0) c.classList.add('head');
      });
      cells[getIndex(food.x, food.y)].classList.add('food');
    }

    function getRandomEmptyCell(levelIdx){
      const empty = [];
      for (let y=0;y<boardSize;y++){
        for (let x=0;x<boardSize;x++){
          if (levels[levelIdx][y][x] === 0) empty.push({x,y});
        }
      }
      return empty[Math.floor(Math.random()*empty.length)];
    }

    // Overlay / countdown
    function showOverlayMessage(html, buttonText, onButton){
      overlayMsg.innerHTML = html;
      countdownEl.textContent = '';
      overlayBtn.style.display = buttonText ? 'inline-block' : 'none';
      if (buttonText) overlayBtn.textContent = buttonText;
      overlay.style.display = 'flex';
      if (buttonText){
        overlayBtn.onclick = () => {
          overlay.style.display = 'none';
          overlayBtn.style.display = 'none';
          if (onButton) onButton();
        };
      }
    }

    function countdownStart(lv=0){
      isCounting = true;
      overlay.style.display = 'flex';
      overlayBtn.style.display = 'none';
      overlayMsg.textContent = `B·∫Øt ƒë·∫ßu Level ${lv+1}`;
      let count = 3;
      countdownEl.textContent = count;
      const tick = setInterval(()=>{
        count--;
        if (count >= 0) countdownEl.textContent = count > 0 ? count : 'GO!';
        else { clearInterval(tick); overlay.style.display = 'none'; countdownEl.textContent = ''; isCounting = false; startGame(lv); }
      }, 700);
    }

    function resetGame(lv=0){ countdownStart(lv); }

    function startGame(lv=0){
      level = lv;
      const spawn = getRandomEmptyCell(level);
      snake = [spawn];
      direction = {x:0,y:-1};
      nextDirection = null;
      let f;
      do { f = getRandomEmptyCell(level); } while (f.x === spawn.x && f.y === spawn.y);
      food = f;
      score = 0; foodEaten = 0;
      scoreDisplay.textContent = score;
      levelDisplay.textContent = level+1;
      statusText.textContent = 'ƒêang ch∆°i';
      draw();
      if (gameInterval) clearInterval(gameInterval);
      const speed = Math.max(70, 150 - level*20);
      gameInterval = setInterval(move, speed);

      // ensure audio on user gesture: if audio enabled and audio context not started, we will start music on first interaction
      if (audioEnabled) {
        initAudioIfNeeded();
        resumeAudioContext();
        startBackgroundMusic();
      }
    }

    // Particles
    let particles = [];
    function resizeParticles(){
      const rect = board.getBoundingClientRect();
      if (!pctx) return;
      const parent = board.parentElement;
      const parentRect = parent.getBoundingClientRect();
      const offsetLeft = rect.left - parentRect.left;
      const offsetTop = rect.top - parentRect.top;
      particlesCanvas.style.position = 'absolute';
      particlesCanvas.style.left = offsetLeft + 'px';
      particlesCanvas.style.top = offsetTop + 'px';
      particlesCanvas.width = Math.round(rect.width);
      particlesCanvas.height = Math.round(rect.height);
      particlesCanvas.style.width = rect.width + 'px';
      particlesCanvas.style.height = rect.height + 'px';
      particlesCanvas.style.pointerEvents = 'none';
    }

    window.addEventListener('resize', resizeParticles);

    function spawnParticles(x,y, color='#ffd27a'){
      if (!pctx) return;
      const br = board.getBoundingClientRect();
      const cell = cells[getIndex(x,y)];
      const cr = cell.getBoundingClientRect();
      const cx = (cr.left - br.left) + cr.width/2;
      const cy = (cr.top - br.top) + cr.height/2;
      const count = 10 + Math.floor(Math.random()*10);
      for (let i=0;i<count;i++){
        particles.push({
          x: cx + (Math.random()-0.5)*12,
          y: cy + (Math.random()-0.5)*12,
          vx: (Math.random()-0.5)*4,
          vy: (Math.random()-1.5)*6 - 1,
          life: 600 + Math.random()*600,
          ttl: 600 + Math.random()*600,
          size: 1 + Math.random()*3,
          color
        });
      }
    }

    let lastTime = performance.now();
    function particlesLoop(now){
      const dt = now - lastTime;
      lastTime = now;
      if (pctx){
        pctx.clearRect(0,0,particlesCanvas.width,particlesCanvas.height);
        for (let i = particles.length-1; i>=0; i--){
          const p = particles[i];
          p.x += p.vx * (dt/16);
          p.y += p.vy * (dt/16);
          p.vy += 0.12 * (dt/16);
          p.life -= dt;
          const alpha = Math.max(0, p.life / p.ttl);
          pctx.globalAlpha = alpha;
          pctx.fillStyle = p.color;
          pctx.beginPath();
          pctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI*2);
          pctx.fill();
          if (p.life <= 0) particles.splice(i,1);
        }
      }
      requestAnimationFrame(particlesLoop);
    }
    requestAnimationFrame(particlesLoop);

    // Movement & game logic
    function move(){
      if (isCounting) return;
      if (nextDirection){
        if (!(direction.x === -nextDirection.x && direction.y === -nextDirection.y)) {
          direction = nextDirection;
        }
        nextDirection = null;
      }
      let head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
      if (head.x < 0) head.x = boardSize - 1;
      if (head.x >= boardSize) head.x = 0;
      if (head.y < 0) head.y = boardSize - 1;
      if (head.y >= boardSize) head.y = 0;
      if (snake.some(p => p.x === head.x && p.y === head.y) || levels[level][head.y][head.x] === 1){
        clearInterval(gameInterval);
        spawnParticles(head.x, head.y, '#ff6b6b');
        playGameOverSound();
        showOverlayMessage(`Game Over!<br>Score: ${score}<br>Quay v·ªÅ Level 1`, 'Ch∆°i l·∫°i', ()=>resetGame(0));
        statusText.textContent = 'Game Over';
        return;
      }
      snake.unshift(head);
      if (head.x === food.x && head.y === food.y){
        score++; foodEaten++;
        scoreDisplay.textContent = score;
        spawnParticles(head.x, head.y, '#ffb347');
        playEatSound();
        if (foodEaten >= 30){
          clearInterval(gameInterval);
          playLevelUpSound();
          if (level < levels.length-1){
            showOverlayMessage(`Ch√∫c m·ª´ng!<br>B·∫°n ƒë√£ qua Level ${level+1}`, 'Ti·∫øp t·ª•c', ()=>resetGame(level+1));
            return;
          } else {
            showOverlayMessage('B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c level!', 'Ch∆°i l·∫°i', ()=>resetGame(0));
            return;
          }
        }
        placeFood();
      } else {
        snake.pop();
      }
      draw();
    }

    function placeFood(){
      let newFood;
      do {
        newFood = {x: Math.floor(Math.random()*boardSize), y: Math.floor(Math.random()*boardSize)};
      } while (snake.some(p=>p.x===newFood.x && p.y===newFood.y) || levels[level][newFood.y][newFood.x] === 1);
      food = newFood;
    }

    // Controls
    document.getElementById('up').onclick = () => { ensureAudioOnGesture(); nextDirection = {x:0,y:-1}; };
    document.getElementById('down').onclick = () => { ensureAudioOnGesture(); nextDirection = {x:0,y:1}; };
    document.getElementById('left').onclick = () => { ensureAudioOnGesture(); nextDirection = {x:-1,y:0}; };
    document.getElementById('right').onclick = () => { ensureAudioOnGesture(); nextDirection = {x:1,y:0}; };

    document.addEventListener('keydown', e => {
      ensureAudioOnGesture();
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') nextDirection = {x:0,y:-1};
      else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') nextDirection = {x:0,y:1};
      else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') nextDirection = {x:-1,y:0};
      else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') nextDirection = {x:1,y:0};
    });

    // Touch swipe
    let touchStartX = 0, touchStartY = 0, touchMoved = false;
    board.addEventListener('touchstart', function(e){
      if (e.touches.length === 1){
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
      }
    }, {passive:true});
    board.addEventListener('touchmove', function(e){
      if (e.touches.length === 1 && !touchMoved){
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        if (Math.abs(dx) > 30 || Math.abs(dy) > 30){
          touchMoved = true;
          let newDir = null;
          if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
          else newDir = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
          if (!(direction.x === -newDir.x && direction.y === -newDir.y)) { direction = newDir; nextDirection = null; }
        }
      }
    }, {passive:true});
    board.addEventListener('touchend', () => { touchMoved = false; });

    // UI buttons
    document.getElementById('resetBtn').addEventListener('click', ()=> { ensureAudioOnGesture(); resetGame(0); });
    document.getElementById('leaveBtn').addEventListener('click', ()=>{
      if (gameInterval) clearInterval(gameInterval);
      stopAndReset();
      showOverlayMessage('B·∫°n ƒë√£ r·ªùi ph√≤ng', 'OK', ()=>{});
    });

    // ensure audio starts only on user gesture
    function ensureAudioOnGesture() {
      if (!audioCtx) {
        initAudioIfNeeded();
      }
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().then(()=> {
          if (audioEnabled) startBackgroundMusic();
        }).catch(()=>{});
      } else {
        if (audioEnabled) startBackgroundMusic();
      }
    }

    // stop & lobby hint
    function stopAndReset(){
      if (gameInterval) clearInterval(gameInterval);
      statusText.textContent = 'ƒêang ·ªü Lobby';
      levelDisplay.textContent = '‚Äî';
      scoreDisplay.textContent = '0';
      cells.forEach(c=> c.className='cell');
      drawLobbyHint();
      // stop music if you want when leaving -- keep music running as configured
    }

    function drawLobbyHint(){
      const prev = document.querySelector('.board-hint');
      if (prev) prev.remove();
      const div = document.createElement('div');
      div.className = 'board-hint';
      div.style.position = 'absolute';
      div.style.left = '50%';
      div.style.top = '50%';
      div.style.transform = 'translate(-50%,-50%)';
      div.style.pointerEvents = 'none';
      div.style.color = '#cfe9ff';
      div.style.fontWeight = '700';
      div.style.fontSize = '13px';
      div.style.letterSpacing = '0.2px';
      div.textContent = 'Nh·∫•n Reset ƒë·ªÉ b·∫Øt ƒë·∫ßu ‚Ä¢ M≈©i t√™n / WASD ƒë·ªÉ di chuy·ªÉn';
      board.appendChild(div);
      setTimeout(()=> div.remove(), 3200);
    }

    // Sound effect triggers integrated inside logic above (playEatSound, playLevelUpSound, playGameOverSound)

    // initial sizing & start
    setTimeout(()=> {
      resizeParticles();
      resetGame(0);
      // if audio is enabled but user hasn't interacted yet, keep context uninitialized until gesture
const toggleBtn = document.getElementById("toggleMusic");
let isPlaying = false;

toggleBtn.addEventListener("click", () => {
  if (isPlaying) {
    bgm.pause();
    toggleBtn.textContent = "üîá B·∫≠t nh·∫°c";
  } else {
    bgm.play();
    toggleBtn.textContent = "üîä T·∫Øt nh·∫°c";
  }
  isPlaying = !isPlaying;
});
    }, 120);
  </script>
</body>
</html>

