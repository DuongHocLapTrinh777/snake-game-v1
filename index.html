<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Snake Game — Mobile Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <style>
    :root{
      --bg-1: #061024;
      --bg-2: #081426;
      --muted: #9fb0c8;
      --accent-2: #7c5cff;
      --accent-3: #00d4ff;
      --gap: 4px;
      --rounded: 12px;
      --shadow-lg: 0 14px 40px rgba(1,6,20,0.7);
      /* default desktop cell size (will be overridden on small screens) */
      --cell: 26px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:
      radial-gradient(800px 400px at 10% 10%, rgba(124,92,255,0.06), transparent 8%),
      radial-gradient(600px 300px at 90% 90%, rgba(0,212,255,0.04), transparent 8%),
      linear-gradient(180deg,var(--bg-1),var(--bg-2));color:#e8f3ff;-webkit-font-smoothing:antialiased;
      overflow:hidden; /* remove page scrollbar */
      -webkit-touch-callout: none; -webkit-user-select: none; -ms-user-select: none; user-select: none;
    }

    /* Layout: full viewport */
    .container{height:100vh;display:flex;align-items:center;justify-content:center;padding:18px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.03);box-shadow:var(--shadow-lg);backdrop-filter:blur(6px)}
    .layout{display:flex;gap:22px;align-items:flex-start;justify-content:center;width:100%;max-width:1220px}
    .leftPanel{width:320px;flex:0 0 320px;max-height:calc(100vh - 80px);overflow:auto;padding-right:6px}
    .centerPanel{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center}

    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent-2),var(--accent-3));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;font-size:18px}
    .subtitle{color:var(--muted);font-size:13px;margin-top:6px}

    .infoCard{display:flex;flex-direction:column;gap:10px}
    .infoRow{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px}

    /* Board card */
    .boardCard{position:relative;border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,0.03);box-shadow:var(--shadow-lg);background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);display:flex;flex-direction:column;align-items:center}

    /* Use CSS variable --cell for grid size */
    #game-board{
      display:grid;
      grid-template-columns: repeat(15, var(--cell));
      grid-template-rows: repeat(15, var(--cell));
      gap: var(--gap);
      background: linear-gradient(180deg, rgba(255,255,255,0.012), transparent);
      padding: var(--gap);
      border-radius: 10px;
      touch-action: none;
      width: calc(15 * var(--cell) + 14 * var(--gap));
      height: calc(15 * var(--cell) + 14 * var(--gap));
      max-width: 100%;
      max-height: 100%;
    }

    .cell{width:var(--cell);height:var(--cell);border-radius:8px;background:linear-gradient(180deg,#0e1520,#0a1118);transition:transform .12s, background .12s, box-shadow .12s;position:relative;overflow:hidden}
    .cell.snake{background:linear-gradient(180deg,#7fc4ff,#2b8aef);box-shadow:0 8px 22px rgba(43,138,239,0.2);transform:scale(1.03)}
    .cell.snake.head::after{content:'';position:absolute;inset:0;border-radius:inherit;box-shadow:0 8px 30px rgba(43,138,239,0.28), 0 0 18px rgba(124,92,255,0.06);mix-blend-mode:screen}
    .cell.food{background:linear-gradient(180deg,#ffd27a,#ff9a5a);box-shadow:0 10px 26px rgba(255,139,79,0.18);transform:scale(1.05);animation:foodPulse 1100ms infinite}
    @keyframes foodPulse{0%{transform:scale(0.98)}50%{transform:scale(1.08)}100%{transform:scale(0.98)}}
    .cell.block{background:linear-gradient(180deg,#2b2f36,#4a4f58);box-shadow:inset 0 -6px 12px rgba(0,0,0,0.4)}

    .controls{display:flex;gap:8px;margin-top:12px}
    .btn{padding:10px 14px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent-2),var(--accent-3));color:white;font-weight:700;cursor:pointer;box-shadow:0 8px 26px rgba(124,92,255,0.14);transition:transform .12s}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:none}
    .btn:active{transform:translateY(1px)}

    #overlay{display:none;position:fixed;inset:0;z-index:1000;background:rgba(1,6,20,0.7);backdrop-filter:blur(6px);align-items:center;justify-content:center}
    .overlay-inner{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center;min-width:320px;max-width:92%}
    .count{font-size:3rem;font-weight:800;margin:10px 0}

    /* Footer fixed so it doesn't increase page height */
    footer{color:var(--muted);text-align:center;margin-top:12px;font-size:13px;position:fixed;left:0;right:0;bottom:12px;pointer-events:none}

    /* ======= Mobile responsive behaviour (no vertical scroll, board scales to viewport) ======= */
    @media (max-width:920px){
      .leftPanel{display:none} /* hide left panel on mobile */
      .layout{width:100%;justify-content:center}
      /* compute cell size dynamically: use the smaller of (available width / 15) and (available height / 15) */
      /* subtract paddings for status/footer/etc (approx 140px) */
      :root{
        /* We'll set --cell using calc with CSS min() */
      }
      /* Use CSS min() to choose the smaller dimension */
      #game-board{
        --cell: calc(min( (100vw - 40px) / 15, (100vh - 160px) / 15 ));
        width: calc(15 * var(--cell) + 14 * var(--gap));
        height: calc(15 * var(--cell) + 14 * var(--gap));
      }
      .controls{gap:6px}
    }

    @media (max-height:600px){
      /* further reduce paddings on very short screens */
      #game-board{ --cell: calc(min( (100vw - 28px) / 15, (100vh - 120px) / 15 )); }
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="layout" role="main">
      <div class="leftPanel">
        <div class="card">
          <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
            <div class="logo">S</div>
            <div>
              <h1 style="margin:0;font-size:18px">Snake — Clean</h1>
              <div class="subtitle">Phòng full-screen (mobile tối ưu)</div>
            </div>
          </div>

          <div class="infoCard" style="margin-top:12px">
            <div class="infoRow"><div>Score</div><div id="scoreDisplay">0</div></div>
            <div class="infoRow"><div>Level</div><div id="levelDisplay">1</div></div>
            <div class="infoRow"><div>Status</div><div id="statusText">Đang ở Lobby</div></div>
            <div style="margin-top:12px;color:var(--muted);font-size:13px">Hướng dẫn: mũi tên / WASD • Hỗ trợ chạm trên mobile</div>
            <div style="display:flex;gap:8px;margin-top:12px">
              <button id="resetBtn" class="btn ghost">Reset</button>
              <button id="leaveBtn" class="btn ghost">Thoát</button>
            </div>
          </div>
        </div>
      </div>

      <div class="centerPanel">
        <div class="boardCard card" style="width:100%;display:flex;flex-direction:column;align-items:center">
          <div id="game-board" aria-label="game board"></div>
          <canvas id="particles" style="position:absolute;left:0;top:0;pointer-events:none;"></canvas>
          <div class="controls" style="margin-top:18px">
            <button id="up" class="btn ghost">▲</button>
            <button id="left" class="btn ghost">◀</button>
            <button id="down" class="btn ghost">▼</button>
            <button id="right" class="btn ghost">▶</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay" role="dialog" aria-hidden="true">
    <div class="overlay-inner">
      <div id="overlayMsg" style="font-weight:700;"></div>
      <div id="countdown" class="count"></div>
      <div style="margin-top:12px"><button id="overlayBtn" class="btn" style="display:none">OK</button></div>
    </div>
  </div>

  <footer>&copy; <span id="year"></span> Snake Game — Clean Edition</footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();

    const boardSize = 15;
    const board = document.getElementById('game-board');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const statusText = document.getElementById('statusText');
    const overlay = document.getElementById('overlay');
    const overlayMsg = document.getElementById('overlayMsg');
    const overlayBtn = document.getElementById('overlayBtn');
    const countdownEl = document.getElementById('countdown');
    const particlesCanvas = document.getElementById('particles');
    const pctx = particlesCanvas.getContext ? particlesCanvas.getContext('2d') : null;

    let snake, direction, food, score, gameInterval, foodEaten, level;
    let nextDirection = null;
    let isCounting = false;
    const cells = [];

    const levels = [
      Array(boardSize).fill(0).map(() => Array(boardSize).fill(0)),
      Array(boardSize).fill(0).map((_, y) => Array(boardSize).fill(0).map((_, x) => (x === 0 || x === boardSize-1 || y === 0 || y === boardSize-1) ? 1 : 0)),
      Array(boardSize).fill(0).map((_, y) => Array(boardSize).fill(0).map((_, x) => (x === Math.floor(boardSize/2) || y === Math.floor(boardSize/2)) ? 1 : 0)),
    ];

    function buildBoard(){
      board.innerHTML = '';
      cells.length = 0;
      for (let y=0; y<boardSize; y++){
        for (let x=0; x<boardSize; x++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.x = x; cell.dataset.y = y;
          board.appendChild(cell);
          cells.push(cell);
        }
      }
      resizeParticles();
      drawLobbyHint();
    }
    buildBoard();

    function getIndex(x,y){ return y * boardSize + x; }

    function draw(){
      cells.forEach(c => c.className = 'cell');
      for (let y=0;y<boardSize;y++){
        for (let x=0;x<boardSize;x++){
          if (levels[level][y][x] === 1) cells[getIndex(x,y)].classList.add('block');
        }
      }
      snake.forEach((part, idx) => {
        const c = cells[getIndex(part.x, part.y)];
        c.classList.add('snake');
        if (idx === 0) c.classList.add('head');
      });
      cells[getIndex(food.x, food.y)].classList.add('food');
    }

    function getRandomEmptyCell(levelIdx){
      const empty = [];
      for (let y=0;y<boardSize;y++){
        for (let x=0;x<boardSize;x++){
          if (levels[levelIdx][y][x] === 0) empty.push({x,y});
        }
      }
      return empty[Math.floor(Math.random()*empty.length)];
    }

    function showOverlayMessage(html, buttonText, onButton){
      overlayMsg.innerHTML = html;
      countdownEl.textContent = '';
      overlayBtn.style.display = buttonText ? 'inline-block' : 'none';
      if (buttonText) overlayBtn.textContent = buttonText;
      overlay.style.display = 'flex';
      if (buttonText){
        overlayBtn.onclick = () => {
          overlay.style.display = 'none';
          overlayBtn.style.display = 'none';
          if (onButton) onButton();
        };
      }
    }

    function countdownStart(lv=0){
      isCounting = true;
      overlay.style.display = 'flex';
      overlayBtn.style.display = 'none';
      overlayMsg.textContent = `Bắt đầu Level ${lv+1}`;
      let count = 3;
      countdownEl.textContent = count;
      const tick = setInterval(()=>{
        count--;
        if (count >= 0) countdownEl.textContent = count > 0 ? count : 'GO!';
        else { clearInterval(tick); overlay.style.display = 'none'; countdownEl.textContent = ''; isCounting = false; startGame(lv); }
      }, 700);
    }

    function resetGame(lv=0){ countdownStart(lv); }

    function startGame(lv=0){
      level = lv;
      const spawn = getRandomEmptyCell(level);
      snake = [spawn];
      direction = {x:0,y:-1};
      nextDirection = null;
      let f;
      do { f = getRandomEmptyCell(level); } while (f.x === spawn.x && f.y === spawn.y);
      food = f;
      score = 0; foodEaten = 0;
      scoreDisplay.textContent = score;
      levelDisplay.textContent = level+1;
      statusText.textContent = 'Đang chơi';
      draw();
      if (gameInterval) clearInterval(gameInterval);
      const speed = Math.max(70, 150 - level*20);
      gameInterval = setInterval(move, speed);
    }

    // Particles & resizing: ensure canvas overlays the board area precisely
    let particles = [];
    function resizeParticles(){
      const rect = board.getBoundingClientRect();
      if (!pctx) return;
      // position canvas relative to board's parent (.boardCard)
      const parentRect = board.parentElement.getBoundingClientRect();
      const offsetLeft = rect.left - parentRect.left;
      const offsetTop = rect.top - parentRect.top;
      particlesCanvas.style.position = 'absolute';
      particlesCanvas.style.left = offsetLeft + 'px';
      particlesCanvas.style.top = offsetTop + 'px';
      particlesCanvas.width = Math.round(rect.width);
      particlesCanvas.height = Math.round(rect.height);
      particlesCanvas.style.width = rect.width + 'px';
      particlesCanvas.style.height = rect.height + 'px';
      particlesCanvas.style.pointerEvents = 'none';
    }

    window.addEventListener('resize', resizeParticles);
    function spawnParticles(x,y, color='#ffd27a'){
      if (!pctx) return;
      const br = board.getBoundingClientRect();
      const cell = cells[getIndex(x,y)];
      const cr = cell.getBoundingClientRect();
      const cx = (cr.left - br.left) + cr.width/2;
      const cy = (cr.top - br.top) + cr.height/2;
      const count = 10 + Math.floor(Math.random()*10);
      for (let i=0;i<count;i++){
        particles.push({
          x: cx + (Math.random()-0.5)*12,
          y: cy + (Math.random()-0.5)*12,
          vx: (Math.random()-0.5)*4,
          vy: (Math.random()-1.5)*6 - 1,
          life: 600 + Math.random()*600,
          ttl: 600 + Math.random()*600,
          size: 1 + Math.random()*3,
          color
        });
      }
    }

    let lastTime = performance.now();
    function particlesLoop(now){
      const dt = now - lastTime;
      lastTime = now;
      if (pctx){
        pctx.clearRect(0,0,particlesCanvas.width,particlesCanvas.height);
        for (let i = particles.length-1; i>=0; i--){
          const p = particles[i];
          p.x += p.vx * (dt/16);
          p.y += p.vy * (dt/16);
          p.vy += 0.12 * (dt/16);
          p.life -= dt;
          const alpha = Math.max(0, p.life / p.ttl);
          pctx.globalAlpha = alpha;
          pctx.fillStyle = p.color;
          pctx.beginPath();
          pctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI*2);
          pctx.fill();
          if (p.life <= 0) particles.splice(i,1);
        }
      }
      requestAnimationFrame(particlesLoop);
    }
    requestAnimationFrame(particlesLoop);

    // Movement & logic
    function move(){
      if (isCounting) return;
      if (nextDirection){
        if (!(direction.x === -nextDirection.x && direction.y === -nextDirection.y)) {
          direction = nextDirection;
        }
        nextDirection = null;
      }
      let head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
      if (head.x < 0) head.x = boardSize - 1;
      if (head.x >= boardSize) head.x = 0;
      if (head.y < 0) head.y = boardSize - 1;
      if (head.y >= boardSize) head.y = 0;
      if (snake.some(p => p.x === head.x && p.y === head.y) || levels[level][head.y][head.x] === 1){
        clearInterval(gameInterval);
        spawnParticles(head.x, head.y, '#ff6b6b');
        showOverlayMessage(`Game Over!<br>Score: ${score}<br>Quay về Level 1`, 'Chơi lại', ()=>resetGame(0));
        statusText.textContent = 'Game Over';
        return;
      }
      snake.unshift(head);
      if (head.x === food.x && head.y === food.y){
        score++; foodEaten++;
        scoreDisplay.textContent = score;
        spawnParticles(head.x, head.y, '#ffb347');
        if (foodEaten >= 30){
          clearInterval(gameInterval);
          if (level < levels.length-1){
            showOverlayMessage(`Chúc mừng!<br>Bạn đã qua Level ${level+1}`, 'Tiếp tục', ()=>resetGame(level+1));
            return;
          } else {
            showOverlayMessage('Bạn đã hoàn thành tất cả các level!', 'Chơi lại', ()=>resetGame(0));
            return;
          }
        }
        placeFood();
      } else {
        snake.pop();
      }
      draw();
    }

    function placeFood(){
      let newFood;
      do {
        newFood = {x: Math.floor(Math.random()*boardSize), y: Math.floor(Math.random()*boardSize)};
      } while (snake.some(p=>p.x===newFood.x && p.y===newFood.y) || levels[level][newFood.y][newFood.x] === 1);
      food = newFood;
    }

    // Controls
    document.getElementById('up').onclick = () => nextDirection = {x:0,y:-1};
    document.getElementById('down').onclick = () => nextDirection = {x:0,y:1};
    document.getElementById('left').onclick = () => nextDirection = {x:-1,y:0};
    document.getElementById('right').onclick = () => nextDirection = {x:1,y:0};

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') nextDirection = {x:0,y:-1};
      else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') nextDirection = {x:0,y:1};
      else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') nextDirection = {x:-1,y:0};
      else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') nextDirection = {x:1,y:0};
    });

    // Touch swipe
    let touchStartX = 0, touchStartY = 0, touchMoved = false;
    board.addEventListener('touchstart', function(e){
      if (e.touches.length === 1){
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
      }
    }, {passive:true});
    board.addEventListener('touchmove', function(e){
      if (e.touches.length === 1 && !touchMoved){
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        if (Math.abs(dx) > 30 || Math.abs(dy) > 30){
          touchMoved = true;
          let newDir = null;
          if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
          else newDir = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
          if (!(direction.x === -newDir.x && direction.y === -newDir.y)) { direction = newDir; nextDirection = null; }
        }
      }
    }, {passive:true});
    board.addEventListener('touchend', () => { touchMoved = false; });

    // UI buttons
    document.getElementById('resetBtn').addEventListener('click', ()=> resetGame(0));
    document.getElementById('leaveBtn').addEventListener('click', ()=>{
      if (gameInterval) clearInterval(gameInterval);
      stopAndReset();
      showOverlayMessage('Bạn đã rời phòng', 'OK', ()=>{});
    });

    // stop & lobby hint
    function stopAndReset(){
      if (gameInterval) clearInterval(gameInterval);
      statusText.textContent = 'Đang ở Lobby';
      levelDisplay.textContent = '—';
      scoreDisplay.textContent = '0';
      cells.forEach(c=> c.className='cell');
      drawLobbyHint();
    }

    function drawLobbyHint(){
      const prev = document.querySelector('.board-hint');
      if (prev) prev.remove();
      const div = document.createElement('div');
      div.className = 'board-hint';
      div.style.position = 'absolute';
      div.style.left = '50%';
      div.style.top = '50%';
      div.style.transform = 'translate(-50%,-50%)';
      div.style.pointerEvents = 'none';
      div.style.color = '#cfe9ff';
      div.style.fontWeight = '700';
      div.style.fontSize = '13px';
      div.style.letterSpacing = '0.2px';
      div.textContent = 'Nhấn Reset để bắt đầu • Mũi tên / WASD để di chuyển';
      board.appendChild(div);
      setTimeout(()=> div.remove(), 3200);
    }

    // initial sizing & start
    setTimeout(()=> {
      resizeParticles();
      resetGame(0);
    }, 120);
  </script>
</body>
</html>
